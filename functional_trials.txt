(fn findodd [x] (if (empty? x) '() (if (= 0 (mod (first x) 2))  (findodd(rest x)) (concat(list (first x)) (findodd(rest x))))))
(fn ! [x] (if (empty? x) '() (if (= 1 (rem (first x) 2))   (concat  (list (first x))  (! (rest x)) )    (! (rest x))   )   )  )

(= (fn interleave [coll1 coll2]
  (if (empty? coll1) 0
    (conj (first coll1) (first coll2) (interleave (rest coll1) (rest coll2)))) [1 2 3] [:a :b :c]) '(1 :a 2 :b 3 :c))





(defn add-to-bill [bill items]
  (loop [row-bill bill, row-item items result[]]
    (if empty? bill result
      ( (if (= (row-bill :name) (row-item :name) )
          ( (conj result (update-in bill [row-bill :quantity] +(row-item :quantity) ) ) ) 
            ( (conj result row-bill row-item) ) ) )
      (recur ((rest bill), (rest items), result)))))


(defn add-to-bill [bill items] 
  (for [row bill :when (= (row :name) (get (first items) :name) ) ]
  (update-in bill [row :quantity] +(get (first items) :quantity) )
(recur (add-to-bill bill (rest items))))

(add-to-bill bill items)
(distinct (into bill items))



(def bill [{:name "Green Tea Ice Cream" :price 2.5 :quantity 2}
 {:price 1.0 :name "Sticky Rice" :quantity 2}])

 
(def items[{:name "Green Tea Ice Cream" :price 24 :quantity 2}{:price 1.0 :name "Mango Rice" :quantity 2} ])


(defn bill-total [coll] (if (empty? coll) 0
                          (+ (* (get (first coll) :price) (get (first coll) :quantity) ) (bill-total (rest coll) ) ) ))
       (def result '())   

(bill-total bill)
(first items)

(defn ifpresent [bill item result]
  (for [row bill :when (= (row :name) (item :name) ) ]
  (conj result (update-in bill [row :quantity] +(item :quantity) ) )) result )

(ifpresent bill (first items) result)

       
(defn add-to-bill [bill items]
  (if (empty? items) '()
    (conj (ifpresent bill (first items))
    (add-to-bill bill (rest items)))))

;(add-to-bill bill items)

(concat items (update-in bill [0 :quantity] +((first items) :quantity) ))

(for [row bill :when (= (get row :name) (get (first items) :name) ) ]
  (update-in bill [row :quantity] +(get (first items) :quantity) ) )
  
  (defn get-keys [result coll]
  (if (empty? coll) result
   ((conj result (get (first coll) [:name])) (get-keys result (rest coll)))))

(get-keys [] bill)

((select-keys (first bill) [:name]) (select-keys (second bill) [:name]))


(defn foo [result row]
(if (empty? (filter #(= % (get (first items) :name)) (get-names [] result) ))
    (conj result (first items))
  (if (= (get row :name) (get (first items) :name))
            (conj result (update-in row [:quantity] + (get (first items) :quantity)))
          )))

(defn item-to-bill [item-row bill]
  (reduce (fn [result row]
            (if (= (get row :name) (get item-row :name))
              (conj result (update-in row [:quantity] + (get item-row :quantity)))
              (conj result row item-row))) [] bill))


(defn add-to-bill [bill items]
  (if (empty? bill) '()
    (do(for [item-row items]
         (item-to-bill item-row bill)))))

(foo [] (first bill))

(reduce foo [] bill)




  (defn get-quantity [result xs]
  (if (empty? xs) result
    (get-quantity (conj result (get (first xs) :quantity) ) (rest xs))
    ))
  
  
